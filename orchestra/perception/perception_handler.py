"""
Perception handler for aggregating events and generating proactive suggestions.
"""

import os
import time
import threading
from typing import Dict, List, Callable, Optional, Set, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
import json
import re

from .fs_watcher import FSEvent, FSWatcher, create_project_fs_watcher
from .git_watcher import GitEvent, GitWatcher, create_project_git_watcher


@dataclass
class Suggestion:
    """Represents a proactive suggestion generated by the perception system."""
    id: str
    type: str  # code_quality, git_workflow, testing, documentation, security
    priority: str  # high, medium, low
    title: str
    description: str
    reasoning: str
    suggested_actions: List[str]
    context: Dict[str, Any]
    created_at: datetime
    expires_at: Optional[datetime] = None
    tags: List[str] = field(default_factory=list)


@dataclass
class PerceptionContext:
    """Context information for perception analysis."""
    project_root: str
    language: Optional[str] = None
    framework: Optional[str] = None
    has_tests: bool = False
    has_ci: bool = False
    has_docs: bool = False
    recent_events: List[Any] = field(default_factory=list)
    git_status: Optional[Dict[str, Any]] = None


class PerceptionHandler:
    """Handles perception events and generates proactive suggestions."""
    
    def __init__(self, 
                 project_root: str,
                 suggestion_callback: Callable[[Suggestion], None],
                 cooldown_seconds: float = None):
        """
        Initialize perception handler.
        
        Args:
            project_root: Root directory of the project
            suggestion_callback: Function to call when suggestions are generated
            cooldown_seconds: Minimum time between suggestions for the same type
        """
        self.project_root = os.path.abspath(project_root)
        self.suggestion_callback = suggestion_callback
        self.cooldown_seconds = cooldown_seconds or float(os.getenv('GTA_PERCEPTION_COOLDOWN', '300'))  # 5 minutes
        
        # Event management
        self.event_buffer = []
        self.buffer_lock = threading.Lock()
        self.last_analysis = time.time()
        self.analysis_interval = float(os.getenv('GTA_PERCEPTION_ANALYSIS_INTERVAL', '30'))  # 30 seconds
        
        # Suggestion tracking
        self.recent_suggestions = {}  # type -> timestamp
        self.suggestion_counter = 0
        
        # Watchers
        self.fs_watcher = None
        self.git_watcher = None
        self.running = False
        
        # Context
        self.context = self._build_initial_context()
        
        # Analysis thread
        self.analysis_thread = None
    
    def _build_initial_context(self) -> PerceptionContext:
        """Build initial project context."""
        context = PerceptionContext(project_root=self.project_root)
        
        # Detect project language and framework
        context.language, context.framework = self._detect_project_type()
        
        # Check for common project components
        context.has_tests = self._has_tests()
        context.has_ci = self._has_ci()
        context.has_docs = self._has_docs()
        
        return context
    
    def _detect_project_type(self) -> tuple[Optional[str], Optional[str]]:
        """Detect project language and framework."""
        # Check for common files that indicate language/framework
        indicators = {
            'python': ['requirements.txt', 'setup.py', 'pyproject.toml', 'Pipfile'],
            'javascript': ['package.json', 'yarn.lock', 'npm-shrinkwrap.json'],
            'typescript': ['tsconfig.json', 'package.json'],
            'java': ['pom.xml', 'build.gradle', 'gradle.properties'],
            'rust': ['Cargo.toml', 'Cargo.lock'],
            'go': ['go.mod', 'go.sum'],
            'cpp': ['CMakeLists.txt', 'Makefile', 'meson.build']
        }
        
        frameworks = {
            'react': ['package.json'],  # Need to check content
            'vue': ['vue.config.js', 'package.json'],
            'angular': ['angular.json', 'package.json'],
            'django': ['manage.py', 'settings.py'],
            'flask': ['app.py', 'requirements.txt'],
            'express': ['package.json'],  # Need to check content
            'spring': ['pom.xml', 'application.properties'],
        }
        
        detected_language = None
        detected_framework = None
        
        # Check for language indicators
        for lang, files in indicators.items():
            for file in files:
                if os.path.exists(os.path.join(self.project_root, file)):
                    detected_language = lang
                    break
            if detected_language:
                break
        
        # Check package.json for JS frameworks
        package_json_path = os.path.join(self.project_root, 'package.json')
        if os.path.exists(package_json_path):
            try:
                with open(package_json_path, 'r') as f:
                    package_data = json.load(f)
                    dependencies = {**package_data.get('dependencies', {}), **package_data.get('devDependencies', {})}
                    
                    if 'react' in dependencies:
                        detected_framework = 'react'
                    elif 'vue' in dependencies:
                        detected_framework = 'vue'
                    elif '@angular/core' in dependencies:
                        detected_framework = 'angular'
                    elif 'express' in dependencies:
                        detected_framework = 'express'
            except:
                pass
        
        return detected_language, detected_framework
    
    def _has_tests(self) -> bool:
        """Check if project has tests."""
        test_indicators = [
            'tests/', 'test/', '__tests__/', 'spec/',
            'pytest.ini', 'jest.config.js', 'karma.conf.js',
            'phpunit.xml', 'Cargo.toml'  # Rust has built-in tests
        ]
        
        for indicator in test_indicators:
            path = os.path.join(self.project_root, indicator)
            if os.path.exists(path):
                return True
        
        # Check for test files
        for root, dirs, files in os.walk(self.project_root):
            for file in files:
                if (file.startswith('test_') or file.endswith('_test.py') or 
                    file.endswith('.test.js') or file.endswith('.spec.js')):
                    return True
        
        return False
    
    def _has_ci(self) -> bool:
        """Check if project has CI/CD setup."""
        ci_indicators = [
            '.github/workflows/', '.gitlab-ci.yml', '.travis.yml',
            'Jenkinsfile', '.circleci/', 'azure-pipelines.yml'
        ]
        
        for indicator in ci_indicators:
            if os.path.exists(os.path.join(self.project_root, indicator)):
                return True
        
        return False
    
    def _has_docs(self) -> bool:
        """Check if project has documentation."""
        doc_indicators = [
            'docs/', 'doc/', 'documentation/', 'README.md', 'README.rst'
        ]
        
        for indicator in doc_indicators:
            if os.path.exists(os.path.join(self.project_root, indicator)):
                return True
        
        return False
    
    def start(self):
        """Start the perception system."""
        if self.running:
            return
        
        print(f"üß† Starting perception system for {self.project_root}")
        self.running = True
        
        # Start filesystem watcher
        try:
            self.fs_watcher = create_project_fs_watcher(self.project_root, self._handle_fs_event)
            if self.fs_watcher:
                self.fs_watcher.start()
        except ImportError:
            print("‚ö†Ô∏è Watchdog not available, filesystem watching disabled")
        except Exception as e:
            print(f"‚ö†Ô∏è Could not start filesystem watcher: {e}")
        
        # Start git watcher
        try:
            self.git_watcher = create_project_git_watcher(self.project_root, self._handle_git_event)
            if self.git_watcher:
                self.git_watcher.start()
        except Exception as e:
            print(f"‚ö†Ô∏è Could not start git watcher: {e}")
        
        # Start analysis thread
        self.analysis_thread = threading.Thread(target=self._analysis_loop, daemon=True)
        self.analysis_thread.start()
        
        print("‚úÖ Perception system started")
    
    def stop(self):
        """Stop the perception system."""
        if not self.running:
            return
        
        print("üõë Stopping perception system")
        self.running = False
        
        if self.fs_watcher:
            self.fs_watcher.stop()
        
        if self.git_watcher:
            self.git_watcher.stop()
        
        if self.analysis_thread:
            self.analysis_thread.join(timeout=5)
    
    def _handle_fs_event(self, event: FSEvent):
        """Handle filesystem event."""
        with self.buffer_lock:
            self.event_buffer.append(('fs', event))
    
    def _handle_git_event(self, event: GitEvent):
        """Handle git event."""
        with self.buffer_lock:
            self.event_buffer.append(('git', event))
    
    def _analysis_loop(self):
        """Main analysis loop."""
        while self.running:
            try:
                time.sleep(self.analysis_interval)
                
                if not self.running:
                    break
                
                # Process buffered events
                with self.buffer_lock:
                    if self.event_buffer:
                        events_to_process = self.event_buffer.copy()
                        self.event_buffer.clear()
                        self._analyze_events(events_to_process)
                
            except Exception as e:
                print(f"Error in perception analysis loop: {e}")
    
    def _analyze_events(self, events: List[tuple]):
        """Analyze events and generate suggestions."""
        if not events:
            return
        
        # Update context with recent events
        self.context.recent_events = events[-20:]  # Keep last 20 events
        
        # Update git status if we have git events
        git_events = [e[1] for e in events if e[0] == 'git']
        if git_events and self.git_watcher:
            self.context.git_status = self.git_watcher.get_watch_info()
        
        # Generate suggestions based on different heuristics
        suggestions = []
        
        suggestions.extend(self._analyze_code_quality(events))
        suggestions.extend(self._analyze_git_workflow(events))
        suggestions.extend(self._analyze_testing_needs(events))
        suggestions.extend(self._analyze_documentation_needs(events))
        suggestions.extend(self._analyze_security_concerns(events))
        
        # Send suggestions
        for suggestion in suggestions:
            if self._should_send_suggestion(suggestion):
                try:
                    self.suggestion_callback(suggestion)
                    self.recent_suggestions[suggestion.type] = time.time()
                except Exception as e:
                    print(f"Error sending suggestion: {e}")
    
    def _should_send_suggestion(self, suggestion: Suggestion) -> bool:
        """Check if suggestion should be sent based on cooldown."""
        last_sent = self.recent_suggestions.get(suggestion.type, 0)
        return time.time() - last_sent >= self.cooldown_seconds
    
    def _create_suggestion(self, type_: str, priority: str, title: str, 
                          description: str, reasoning: str, actions: List[str],
                          context: Dict[str, Any] = None, tags: List[str] = None,
                          expires_minutes: int = None) -> Suggestion:
        """Create a suggestion with proper ID and timestamps."""
        self.suggestion_counter += 1
        
        expires_at = None
        if expires_minutes:
            expires_at = datetime.now() + timedelta(minutes=expires_minutes)
        
        return Suggestion(
            id=f"perception_{self.suggestion_counter}_{int(time.time())}",
            type=type_,
            priority=priority,
            title=title,
            description=description,
            reasoning=reasoning,
            suggested_actions=actions,
            context=context or {},
            created_at=datetime.now(),
            expires_at=expires_at,
            tags=tags or []
        )
    
    def _analyze_code_quality(self, events: List[tuple]) -> List[Suggestion]:
        """Analyze events for code quality suggestions."""
        suggestions = []
        
        # Look for many small file changes (potential refactoring opportunity)
        fs_events = [e[1] for e in events if e[0] == 'fs']
        modified_files = [e for e in fs_events if e.event_type == 'modified']
        
        if len(modified_files) > 10:  # Many file modifications
            code_files = [e for e in modified_files 
                         if any(e.path.endswith(ext) for ext in ['.py', '.js', '.ts', '.java', '.cpp', '.rs'])]
            
            if len(code_files) > 5:
                suggestions.append(self._create_suggestion(
                    type_='code_quality',
                    priority='medium',
                    title='Multiple File Changes Detected',
                    description='You\'ve modified many code files recently. Consider refactoring common patterns.',
                    reasoning=f'Detected {len(code_files)} code file modifications, suggesting potential code duplication.',
                    actions=[
                        'Review modified files for common patterns',
                        'Consider extracting shared functionality',
                        'Run code analysis tools to identify duplication'
                    ],
                    context={'modified_files': [e.path for e in code_files[:10]]},
                    tags=['refactoring', 'code_quality'],
                    expires_minutes=60
                ))
        
        return suggestions
    
    def _analyze_git_workflow(self, events: List[tuple]) -> List[Suggestion]:
        """Analyze events for git workflow suggestions."""
        suggestions = []
        
        git_events = [e[1] for e in events if e[0] == 'git']
        
        # Check for uncommitted changes accumulating
        status_changes = [e for e in git_events if e.event_type == 'status_changed']
        if status_changes:
            latest_status = status_changes[-1]
            total_changes = latest_status.details.get('total_changes', 0)
            
            if total_changes > 10:
                suggestions.append(self._create_suggestion(
                    type_='git_workflow',
                    priority='medium',
                    title='Many Uncommitted Changes',
                    description=f'You have {total_changes} uncommitted changes. Consider making smaller, focused commits.',
                    reasoning='Large changesets are harder to review and debug.',
                    actions=[
                        'Review changes with `git status`',
                        'Stage related changes with `git add -p`',
                        'Make focused commits with descriptive messages',
                        'Consider using feature branches for large changes'
                    ],
                    context={'total_changes': total_changes},
                    tags=['git', 'workflow'],
                    expires_minutes=30
                ))
        
        # Check for conflicts
        conflict_events = [e for e in git_events if e.event_type == 'conflict_detected']
        if conflict_events:
            suggestions.append(self._create_suggestion(
                type_='git_workflow',
                priority='high',
                title='Merge Conflicts Detected',
                description='Git conflicts were detected. Resolve them to continue development.',
                reasoning='Conflicts prevent normal development workflow.',
                actions=[
                    'Run `git status` to see conflicted files',
                    'Edit conflicted files to resolve markers',
                    'Stage resolved files with `git add`',
                    'Complete merge with `git commit`'
                ],
                context={'conflicts': len(conflict_events)},
                tags=['git', 'conflict', 'urgent'],
                expires_minutes=15
            ))
        
        return suggestions
    
    def _analyze_testing_needs(self, events: List[tuple]) -> List[Suggestion]:
        """Analyze events for testing suggestions."""
        suggestions = []
        
        # If project doesn't have tests, suggest adding them
        if not self.context.has_tests:
            fs_events = [e[1] for e in events if e[0] == 'fs']
            code_files = [e for e in fs_events 
                         if e.event_type in ['created', 'modified'] and
                         any(e.path.endswith(ext) for ext in ['.py', '.js', '.ts', '.java'])]
            
            if len(code_files) > 3:  # Significant code activity without tests
                suggestions.append(self._create_suggestion(
                    type_='testing',
                    priority='high',
                    title='No Tests Detected',
                    description='Your project lacks tests but has active development. Consider adding automated tests.',
                    reasoning='Tests help catch bugs early and enable confident refactoring.',
                    actions=[
                        'Create a tests directory',
                        'Add a testing framework (pytest, jest, etc.)',
                        'Write tests for critical functionality',
                        'Set up test automation in CI/CD'
                    ],
                    context={'language': self.context.language, 'framework': self.context.framework},
                    tags=['testing', 'quality_assurance'],
                    expires_minutes=120
                ))
        
        return suggestions
    
    def _analyze_documentation_needs(self, events: List[tuple]) -> List[Suggestion]:
        """Analyze events for documentation suggestions."""
        suggestions = []
        
        # Check for new code without documentation
        fs_events = [e[1] for e in events if e[0] == 'fs']
        new_code_files = [e for e in fs_events 
                         if e.event_type == 'created' and
                         any(e.path.endswith(ext) for ext in ['.py', '.js', '.ts', '.java'])]
        
        if len(new_code_files) > 0 and not self.context.has_docs:
            suggestions.append(self._create_suggestion(
                type_='documentation',
                priority='low',
                title='Consider Adding Documentation',
                description='New code files created without project documentation. Consider documenting your project.',
                reasoning='Good documentation helps onboard contributors and users.',
                actions=[
                    'Create a README.md file',
                    'Document API endpoints or public interfaces',
                    'Add inline code comments',
                    'Consider setting up a docs/ directory'
                ],
                context={'new_files': [e.path for e in new_code_files]},
                tags=['documentation', 'maintenance'],
                expires_minutes=240
            ))
        
        return suggestions
    
    def _analyze_security_concerns(self, events: List[tuple]) -> List[Suggestion]:
        """Analyze events for security suggestions."""
        suggestions = []
        
        fs_events = [e[1] for e in events if e[0] == 'fs']
        
        # Check for sensitive files
        sensitive_patterns = ['.env', 'config.json', 'secrets', 'password', 'key', 'token']
        sensitive_files = []
        
        for event in fs_events:
            if event.event_type in ['created', 'modified']:
                filename = os.path.basename(event.path).lower()
                if any(pattern in filename for pattern in sensitive_patterns):
                    sensitive_files.append(event.path)
        
        if sensitive_files:
            suggestions.append(self._create_suggestion(
                type_='security',
                priority='high',
                title='Sensitive Files Modified',
                description='Files that might contain sensitive information were modified.',
                reasoning='Sensitive files should be properly secured and not committed to version control.',
                actions=[
                    'Review sensitive files for hardcoded secrets',
                    'Add sensitive files to .gitignore',
                    'Use environment variables for secrets',
                    'Consider using a secrets management tool'
                ],
                context={'sensitive_files': sensitive_files},
                tags=['security', 'secrets'],
                expires_minutes=60
            ))
        
        return suggestions
    
    def get_status(self) -> Dict[str, Any]:
        """Get current perception system status."""
        return {
            "running": self.running,
            "project_root": self.project_root,
            "context": {
                "language": self.context.language,
                "framework": self.context.framework,
                "has_tests": self.context.has_tests,
                "has_ci": self.context.has_ci,
                "has_docs": self.context.has_docs
            },
            "watchers": {
                "fs_watcher": self.fs_watcher.get_watch_info() if self.fs_watcher else None,
                "git_watcher": self.git_watcher.get_watch_info() if self.git_watcher else None
            },
            "recent_suggestions": len(self.recent_suggestions),
            "event_buffer_size": len(self.event_buffer)
        }
